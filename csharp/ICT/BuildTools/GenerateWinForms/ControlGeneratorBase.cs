//
// DO NOT REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
//
// @Authors:
//       timop
//
// Copyright 2004-2013 by OM International
//
// This file is part of OpenPetra.org.
//
// OpenPetra.org is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// OpenPetra.org is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with OpenPetra.org.  If not, see <http://www.gnu.org/licenses/>.
//
using System;
using System.Xml;
using System.Collections.Specialized;
using System.Collections.Generic;
using System.Windows.Forms;
using Ict.Tools.CodeGeneration;
using Ict.Tools.DBXML;
using Ict.Common.IO;
using Ict.Common;

namespace Ict.Tools.CodeGeneration.Winforms
{
    /// <summary>
    /// base for the control generators
    /// </summary>
    public class TControlGenerator : IControlGenerator
    {
        /// <summary>controls with this prefix should be generated by this generator</summary>
        public string FPrefix;
        /// <summary>dotnet type of the control</summary>
        public string FControlType;
        /// <summary>should the control size automatically </summary>
        public bool FAutoSize = false;
        /// <summary>is there a specified location for the control</summary>
        public bool FLocation = true;
        /// <summary>should a label be generated for this control</summary>
        public bool FGenerateLabel = true;

        /// the readonly property eg of Textbox still allows tooltips and copy to clipboard, which enable=false would not allow
        public bool FHasReadOnlyProperty = false;
        /// should the control be added to the parent container
        public bool FAddControlToContainer = true;
        /// name of the template snippet used for the code generation of the control
        public string FTemplateSnippetName = "";
        /// <summary>does this control require children</summary>
        public bool FRequiresChildren = false;
        /// <summary>default width for control</summary>
        public Int32 FDefaultWidth = 150;
        /// <summary>default height for control</summary>
        public Int32 FDefaultHeight = 28;
        /// <summary>the representation of the code to be generated</summary>
        public static TCodeStorage FCodeStorage;

        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="APrefix"></param>
        /// <param name="AControlType"></param>
        public TControlGenerator(string APrefix, System.Type AControlType)
            : this(APrefix, AControlType.ToString())
        {
        }

        /// <summary>
        /// constructor
        /// </summary>
        /// <param name="APrefix"></param>
        /// <param name="AControlType"></param>
        public TControlGenerator(string APrefix, string AControlType)
        {
            FPrefix = APrefix;
            FControlType = AControlType;
            FTemplateSnippetName = AControlType;

            if (FTemplateSnippetName.IndexOf(".") != -1)
            {
                FTemplateSnippetName = FTemplateSnippetName.Substring(FTemplateSnippetName.LastIndexOf(".") + 1).ToUpper();
            }
        }

        /// <summary>
        /// should this control only be created if there are children controls? eg toolbar
        /// </summary>
        public bool RequiresChildren
        {
            get
            {
                return FRequiresChildren;
            }
        }

        /// <summary>
        /// get the label text for this control
        /// </summary>
        /// <param name="ctrl"></param>
        /// <returns></returns>
        public virtual bool GenerateLabel(TControlDef ctrl)
        {
            if (ctrl.HasAttribute("NoLabel") && (ctrl.GetAttribute("NoLabel").ToLower() == "true"))
            {
                ctrl.hasLabel = false;
                return false;
            }

            ctrl.hasLabel = FGenerateLabel;
            return ctrl.hasLabel;
        }

        /// <summary>
        /// dotnet type of the control
        /// </summary>
        public String ControlType
        {
            get
            {
                return FControlType;
            }
            set
            {
                FControlType = value;
            }
        }

        /// <summary>
        /// the name of the snippet in the template for Readcontrols and setcontrols, in captial letters
        /// </summary>
        public string TemplateSnippetName
        {
            get
            {
                return FTemplateSnippetName;
            }
            set
            {
                FTemplateSnippetName = value;
            }
        }

        /// <summary>
        /// should the control be added to the parent container
        /// </summary>
        public bool AddControlToContainer
        {
            get
            {
                return FAddControlToContainer;
            }
            set
            {
                FAddControlToContainer = value;
            }
        }

        /// use the prefix to see if the control matches the current class
        public bool SimplePrefixMatch(XmlNode curNode)
        {
            return curNode.Name.StartsWith(FPrefix);
        }

        /// overwrite for more complicated matches,
        /// if the same prefix is used for more than one control type
        /// e.g. txt
        public virtual bool ControlFitsNode(XmlNode curNode)
        {
            return SimplePrefixMatch(curNode);
        }

        /// <summary>
        /// generate all code for the control
        /// </summary>
        public void GenerateControl(TFormWriter writer, TControlDef ctrl)
        {
            GenerateDeclaration(writer, ctrl);
            ProcessChildren(writer, ctrl);
            SetControlProperties(writer, ctrl);
            OnChangeDataType(writer, ctrl.xmlNode, ctrl.controlName);
            writer.InitialiseDataSource(ctrl.xmlNode, ctrl.controlName);
            writer.ApplyDerivedFunctionality(this, ctrl);
            AddChildren(writer, ctrl);
        }

        /// <summary>
        /// declaration and code creation in the designer file
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        public virtual void GenerateDeclaration(TFormWriter writer, TControlDef ctrl)
        {
            string localControlType = ControlType;

            if (ctrl.controlType.Length > 0)
            {
                localControlType = ctrl.controlType;
            }

            writer.Template.AddToCodelet("CONTROLDECLARATION", "private " + localControlType + " " + ctrl.controlName + ";" + Environment.NewLine);
            writer.Template.AddToCodelet("CONTROLCREATION", "this." + ctrl.controlName + " = new " + localControlType + "();" + Environment.NewLine);

            // TODO generate a property that can be accessed from outside
        }

        /// <summary>
        /// add the children to this control
        /// </summary>
        public virtual void AddChildren(TFormWriter writer, TControlDef ctrl)
        {
        }

        /// <summary>
        /// generate the children, and write the size of this control
        /// </summary>
        public virtual void ProcessChildren(TFormWriter writer, TControlDef ctrl)
        {
        }

        /// <summary>
        /// how to assign a value to the control
        /// </summary>
        protected virtual string AssignValue(TControlDef ctrl, string AFieldOrNull, string AFieldTypeDotNet)
        {
            if (AFieldOrNull == null)
            {
                return ctrl.controlName + ".Value = null;";
            }

            return ctrl.controlName + ".Value = " + AFieldOrNull + ";";
        }

        /// <summary>
        /// how to undo the change of a value of a control
        /// </summary>
        protected virtual string UndoValue(TControlDef ctrl, string AFieldOrNull, string AFieldTypeDotNet)
        {
            return AssignValue(ctrl, AFieldOrNull + ".ToString()", AFieldTypeDotNet);
        }

        /// <summary>
        /// for coding the transfer of the value from control to dataset
        /// </summary>
        /// <param name="ctrl"></param>
        /// <param name="AFieldTypeDotNet">if this is null, check for the NULL value of the control; otherwise cast the value of the control to the value of the field in the dataset</param>
        /// <returns></returns>
        protected virtual string GetControlValue(TControlDef ctrl, string AFieldTypeDotNet)
        {
            if (AFieldTypeDotNet == null)
            {
                return ctrl.controlName + ".Value == null";
            }

            return ctrl.controlName + ".Value";
        }

        /// <summary>
        /// overload
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        /// <param name="AEvent">Click or DoubleClick or other</param>
        /// <param name="ActionToPerform"></param>
        public void AssignEventHandlerToControl(TFormWriter writer, TControlDef ctrl, string AEvent, string ActionToPerform)
        {
            AssignEventHandlerToControl(writer, ctrl, AEvent, "System.EventHandler", ActionToPerform);
        }

        /// <summary>
        /// assign event handler to control
        /// </summary>
        public void AssignEventHandlerToControl(TFormWriter writer, TControlDef ctrl, string AEvent, string AEventHandlerType, string ActionToPerform)
        {
            if ((AEvent == null) || (AEvent.Length == 0))
            {
                return;
            }

            if (ActionToPerform.StartsWith("act"))
            {
                TActionHandler ActionHandler = writer.CodeStorage.FActionList[ActionToPerform];

                if (ActionHandler.actionId.Length > 0)
                {
                    // actionId is managed by FPetraUtilsObject
                    // need a special function that wraps calls to FPetraUtilsObject, otherwise problems in designer
                    ActionToPerform = ActionHandler.actionName;
                }
                else if (ActionHandler.actionClick.Length > 0)
                {
                    if (ActionHandler.actionClick.StartsWith("FPetraUtilsObject"))
                    {
                        // need a special function that wraps calls to FPetraUtilsObject, otherwise problems in designer
                        ActionToPerform = ActionHandler.actionName;
                    }
                    else
                    {
                        // direct call
                        ActionToPerform = ActionHandler.actionClick;
                    }
                }
                else
                {
                    ActionToPerform = "";
                }
            }
            else
            {
                // direct call: use ActionToPerform
            }

            if (ActionToPerform.Length > 0)
            {
                writer.SetEventHandlerToControl(ctrl.controlName, AEvent, AEventHandlerType, ActionToPerform);
            }
        }

        /// <summary>
        /// action is enabled, enable the controls depending on the action
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ActionCondition"></param>
        /// <param name="ControlName"></param>
        public void AddToActionEnabledEvent(TFormWriter writer, string ActionCondition, string ControlName)
        {
            writer.Template.AddToCodelet(
                "ENABLEDEPENDINGACTIONS_" + ActionCondition,
                ControlName + ".Enabled = e.Enabled;" + Environment.NewLine);
        }

        /// <summary>
        /// name of the event name for when the value has changed
        /// </summary>
        protected string FChangeEventName = "ValueChanged";
        /// <summary>
        /// type of the event handler for this control for the change event
        /// </summary>
        protected string FChangeEventHandlerType = "System.EventHandler";

        /// <summary>
        /// to assign event handler for the event that the value of the control has changed
        /// </summary>
        /// <returns></returns>
        public string GetEventNameForChangeEvent()
        {
            return FChangeEventName;
        }

        /// <summary>
        /// get the type of event handler for the change event for this control
        /// </summary>
        /// <returns></returns>
        public string GetEventHandlerTypeForChangeEvent()
        {
            return FChangeEventHandlerType;
        }

        /// <summary>write the code for the designer file where the properties of the control are written</summary>
        public virtual ProcessTemplate SetControlProperties(TFormWriter writer, TControlDef ctrl)
        {
            bool AutomDataValidation;
            string ReasonForAutomValidation;
            bool IsDetailNotMaster;

            writer.SetControlProperty(ctrl, "Name", "\"" + ctrl.controlName + "\"");

            if (FLocation && !ctrl.HasAttribute("Dock"))
            {
                writer.SetControlProperty(ctrl, "Location", "new System.Drawing.Point(2,2)");
            }

            #region Aligning and stretching

            if (ctrl.HasAttribute("Align")
                && !(ctrl.HasAttribute("Stretch")))
            {
                if ((ctrl.GetAttribute("Align").ToLower() == "right")
                    || (ctrl.GetAttribute("Align").ToLower() == "top-right"))
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right)))");
                }
                else if (ctrl.GetAttribute("Align").ToLower() == "middle-right")
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.Right))");
                }
                else if (ctrl.GetAttribute("Align").ToLower() == "bottom-right")
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)))");
                }
                else if ((ctrl.GetAttribute("Align").ToLower() == "center")
                         || (ctrl.GetAttribute("Align").ToLower() == "top-center"))
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.Top))");
                }
                else if (ctrl.GetAttribute("Align").ToLower() == "middle-center")
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.None))");
                }
                else if (ctrl.GetAttribute("Align").ToLower() == "bottom-center")
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.Bottom))");
                }
                else if ((ctrl.GetAttribute("Align").ToLower() == "bottom")
                         || (ctrl.GetAttribute("Align").ToLower() == "bottom-left"))
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Bottom)))");
                }
                else if ((ctrl.GetAttribute("Align").ToLower() == "middle")
                         || (ctrl.GetAttribute("Align").ToLower() == "middle-left"))
                {
                    writer.SetControlProperty(ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(System.Windows.Forms.AnchorStyles.Left))");
                }
                else if ((ctrl.GetAttribute("Align").ToLower() == "left")
                         || (ctrl.GetAttribute("Align").ToLower() == "top")
                         || (ctrl.GetAttribute("Align").ToLower() == "top-left"))
                {
                    // do nothing (here just to avoid throwing the following Exception)
                    Console.WriteLine(
                        "HINT: Attribute 'Align' with value 'left', 'top' or 'top-left' does not affect the layout since these create the default alignment. Control: '"
                        +
                        ctrl.controlName + "'.");
                }
                else
                {
                    throw new Exception("Invalid value for Attribute 'Align' of Control '" + ctrl.controlName + "': '" + ctrl.GetAttribute(
                            "Align") +
                        "'. Supported values are: Simple: left, right, center; top, middle, bottom; Combined: top-left, middle-left, bottom-left, top-center, middle-center, bottom-center, top-right, middle-right, bottom-right.");
                }
            }

            if (ctrl.HasAttribute("Stretch"))
            {
                if (ctrl.GetAttribute("Stretch").ToLower() == "horizontally")
                {
                    if ((!ctrl.HasAttribute("Align"))
                        || (ctrl.HasAttribute("Align") && (ctrl.GetAttribute("Align").ToLower() == "top")))
                    {
                        // Horizontally stretched, top aligned (=default)
                        writer.SetControlProperty(
                            ctrl,
                            "Anchor",
                            "((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)))");
                    }
                    else
                    {
                        if (ctrl.GetAttribute("Align").ToLower() == "bottom")
                        {
                            // Horizontally stretched, bottom aligned
                            writer.SetControlProperty(
                                ctrl,
                                "Anchor",
                                "((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right)))");
                        }
                        else if (ctrl.GetAttribute("Align").ToLower() == "middle")
                        {
                            // Horizontally stretched, vertically centered
                            writer.SetControlProperty(
                                ctrl,
                                "Anchor",
                                "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)))");
                        }
                        else
                        {
                            throw new Exception("Invalid value '" + ctrl.GetAttribute(
                                    "Align") + "' for Attribute 'Align' of Control '" + ctrl.controlName +
                                "' whose Attribute 'Stretch' is set to '" +
                                ctrl.GetAttribute("Stretch") +
                                "'. Supported values are: top, middle, bottom.");
                        }
                    }
                }
                else if (ctrl.GetAttribute("Stretch").ToLower() == "vertically")
                {
                    if ((!ctrl.HasAttribute("Align"))
                        || (ctrl.HasAttribute("Align") && (ctrl.GetAttribute("Align").ToLower() == "left")))
                    {
                        // Vertically stretched, left aligned (=default)
                        writer.SetControlProperty(
                            ctrl,
                            "Anchor",
                            "((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Bottom)))");
                    }
                    else
                    {
                        if (ctrl.GetAttribute("Align").ToLower() == "right")
                        {
                            // Vertically stretched, right aligned
                            writer.SetControlProperty(
                                ctrl,
                                "Anchor",
                                "((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Right) | System.Windows.Forms.AnchorStyles.Bottom)))");
                        }
                        else if (ctrl.GetAttribute("Align").ToLower() == "center")
                        {
                            // Vertically stretched, horizontally centered
                            writer.SetControlProperty(
                                ctrl,
                                "Anchor",
                                "((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)))");
                        }
                        else
                        {
                            throw new Exception("Invalid value '" + ctrl.GetAttribute(
                                    "Align") + "' for Attribute 'Align' of Control '" + ctrl.controlName +
                                "' whose Attribute 'Stretch' is set to  '" +
                                ctrl.GetAttribute("Stretch") +
                                "'. Supported values are: left, center, right.");
                        }
                    }
                }
                else if (ctrl.GetAttribute("Stretch").ToLower() == "fully")
                {
                    // Fully stretched
                    writer.SetControlProperty(
                        ctrl,
                        "Anchor",
                        "((System.Windows.Forms.AnchorStyles)(((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left) | System.Windows.Forms.AnchorStyles.Right) | System.Windows.Forms.AnchorStyles.Bottom))))");

                    if (ctrl.HasAttribute("Align"))
                    {
                        Console.WriteLine(
                            "WARNING for Control '" + ctrl.controlName +
                            "': Attribute 'Align' gets ignored when Attribute 'Stretch' with value 'fully' is used.");
                    }
                }
                else if (ctrl.GetAttribute("Stretch").ToLower() == "none")
                {
                    // do nothing (here just to avoid throwing the following Exception)
                    Console.WriteLine(
                        "HINT: Attribute 'Stretch' with value 'none' does not affect the layout since this is the default. Control: '" +
                        ctrl.controlName + "'.");
                }
                else
                {
                    throw new Exception("Invalid value for Attribute 'Stretch' of Control '" + ctrl.controlName + "': '" +
                        ctrl.GetAttribute("Stretch") + "'. Supported values are: horizontally, vertically, fully, none.");
                }
            }

            #endregion

            if (ctrl.HasAttribute("Dock"))
            {
                writer.SetControlProperty(ctrl, "Dock");
            }

            if (ctrl.HasAttribute("Visible")
                && (ctrl.GetAttribute("Visible").ToLower() == "false"))
            {
                writer.SetControlProperty(ctrl, "Visible", "false");
            }

            if (ctrl.HasAttribute("Enabled")
                && (ctrl.GetAttribute("Enabled").ToLower() == "false"))
            {
                writer.SetControlProperty(ctrl, "Enabled", "false");
            }
            else if ((ctrl.GetAction() != null) && (TYml2Xml.GetAttribute(ctrl.GetAction().actionNode, "InitiallyEnabled").ToLower() == "false"))
            {
                string ActionEnabling = ctrl.controlName + ".Enabled = false;" + Environment.NewLine;
                writer.Template.AddToCodelet("INITACTIONSTATE", ActionEnabling);
            }

            if (ctrl.HasAttribute("TabStop")
                && (ctrl.GetAttribute("TabStop").ToLower() == "false"))
            {
                writer.SetControlProperty(ctrl, "TabStop", "false");
            }

            if (ctrl.HasAttribute("TabIndex"))
            {
                writer.SetControlProperty(ctrl, "TabIndex", ctrl.GetAttribute("TabIndex"));
            }

            if (ctrl.HasAttribute("BorderStyle"))
            {
                writer.SetControlProperty(ctrl, "BorderStyle", "System.Windows.Forms.BorderStyle." + ctrl.GetAttribute("BorderStyle"));

                if (ctrl.GetAttribute("BorderStyle").ToLower() == "none")
                {
                    writer.SetControlProperty(ctrl, "Margin", "new System.Windows.Forms.Padding(0, 5, 0, 0)");
                }
            }

            if (ctrl.HasAttribute("Padding"))
            {
                writer.SetControlProperty(ctrl, "Padding", "new System.Windows.Forms.Padding(" + ctrl.GetAttribute("Padding") + ")");
            }

            if (ctrl.HasAttribute("Margin"))
            {
                string margin = ctrl.GetAttribute("Margin");

                if (margin != "0")
                {
                    writer.SetControlProperty(ctrl, "Margin", "new System.Windows.Forms.Padding(" + margin + ")");
                }
            }

            if (ctrl.HasAttribute("BackColor"))
            {
                writer.SetControlProperty(ctrl, "BackColor", ctrl.GetAttribute("BackColor"));
            }

            if (ctrl.HasAttribute("AutoScroll"))
            {
                writer.SetControlProperty(ctrl, "AutoScroll", ctrl.GetAttribute("AutoScroll"));
            }

            // needed so that ctrl.Height and ctrl.Width return correct values
            ctrl.SetAttribute("DefaultWidth", FDefaultWidth.ToString());
            ctrl.SetAttribute("DefaultHeight", FDefaultHeight.ToString());

            if (ctrl.HasAttribute("Width") || ctrl.HasAttribute("Height"))
            {
                if (!ctrl.HasAttribute("Width"))
                {
                    ctrl.SetAttribute("Width", FDefaultWidth.ToString());
                }

                if (!ctrl.HasAttribute("Height"))
                {
                    ctrl.SetAttribute("Height", FDefaultHeight.ToString());
                }

                if (ctrl.HasAttribute("Width") && ctrl.HasAttribute("Height"))
                {
                    writer.SetControlProperty(ctrl, "Size", "new System.Drawing.Size(" +
                        ctrl.GetAttribute("Width").ToString() + ", " + ctrl.GetAttribute("Height").ToString() + ")");
                }
            }
            else if (ctrl.GetAttribute("Dock").ToLower() == "fill")
            {
                // no size information for Dock Fill
            }
            else
            {
                writer.SetControlProperty(ctrl, "Size",
                    "new System.Drawing.Size(" + FDefaultWidth.ToString() + ", " + FDefaultHeight.ToString() + ")");
            }

            if (ctrl.HasAttribute("SuppressChangeDetection") && (ctrl.GetAttribute("SuppressChangeDetection").ToLower() == "true"))
            {
                writer.SetControlProperty(ctrl, "Tag", "\"SuppressChangeDetection\"");
            }

            if (ctrl.GetAction() != null)
            {
                string ActionToPerform = ctrl.GetAction().actionName;

                // deal with enabling and disabling of action, affecting the menu item
                if (!writer.Template.FCodelets.Keys.Contains("ENABLEDEPENDINGACTIONS_" + ActionToPerform))
                {
                    string ActionEnabling = "";
                    ActionEnabling += "if (e.ActionName == \"" + ActionToPerform + "\")" + Environment.NewLine;
                    ActionEnabling += "{" + Environment.NewLine;
                    ActionEnabling += "    {#ENABLEDEPENDINGACTIONS_" + ActionToPerform + "}" + Environment.NewLine;
                    ActionEnabling += "}" + Environment.NewLine;
                    writer.Template.AddToCodelet("ACTIONENABLING", ActionEnabling);
                }

                AddToActionEnabledEvent(writer, ActionToPerform, ctrl.controlName);

                // deal with action handler
                AssignEventHandlerToControl(writer, ctrl, "Click", ActionToPerform);

                TActionHandler ActionHandler = writer.CodeStorage.FActionList[ActionToPerform];
                SetControlActionProperties(writer, ctrl, ActionHandler);

                if (FCodeStorage.ManualFileExistsAndContains(" " + ActionHandler.actionName.Substring(3) + "(Form AParentForm)"))
                {
                    writer.SetEventHandlerFunction(ActionHandler.actionName.Substring(3), "", ActionHandler.actionName.Substring(
                            3) + "(this);");
                }
            }
            else if (ctrl.HasAttribute("ActionClick"))
            {
                if (ctrl.GetAttribute("ActionClick") == "MniFilterFind_Click")
                {
                    // MniFilterFind_Click is part of the base template for many forms.
                    // We only create an action handler if the screen has a pnlFilterAndFind
                    if (writer.FCodeStorage.FControlList.ContainsKey("pnlFilterAndFind"))
                    {
                        AssignEventHandlerToControl(writer, ctrl, "Click", ctrl.GetAttribute("ActionClick"));
                        
                        // The manual code sometimes contains a handler, but if not we write a standard one to the auto-generated file
                        // Filter and Find menu items both use the same handler code - so we ensure we only write this action handler once!
                        if (!writer.FCodeStorage.ManualFileExistsAndContains("void MniFilterFind_Click(") && (ctrl.controlName == "mniEditFilter"))
                        {
                            string ActionHandler =
                                "/// auto generated" + Environment.NewLine +
                                "protected void MniFilterFind_Click(object sender, EventArgs e)" + Environment.NewLine +
                                "{" + Environment.NewLine +
                                "    if (FucoFilterAndFind == null)" + Environment.NewLine +
                                "    {" + Environment.NewLine +
                                "        ToggleFilter();" + Environment.NewLine +
                                "    }" + Environment.NewLine + Environment.NewLine +
                                "    if (((ToolStripMenuItem)sender).Name == \"mniEditFind\")" + Environment.NewLine +
                                "    {" + Environment.NewLine +
                                "        FucoFilterAndFind.DisplayFindTab();" + Environment.NewLine +
                                "        FFindPanelControls.FFindPanels[0].PanelControl.Focus();" + Environment.NewLine +
                                "    }" + Environment.NewLine +
                                "    else" + Environment.NewLine +
                                "    {" + Environment.NewLine +
                                "        FucoFilterAndFind.DisplayFilterTab();" + Environment.NewLine +
                                "        FFilterPanelControls.FStandardFilterPanels[0].PanelControl.Focus();" + Environment.NewLine +
                                "    }" + Environment.NewLine +
                                "}" + Environment.NewLine + Environment.NewLine;
                            writer.FCodeStorage.FActionHandlers += ActionHandler;
                        }
                    }
                }
                else
                {
                    // The control is not mniEditFilter or mniEditFind, so just write the resource file item
                    // The manual code file will have the event handler itself
                    AssignEventHandlerToControl(writer, ctrl, "Click", ctrl.GetAttribute("ActionClick"));
                }
            }
            else if (ctrl.HasAttribute("ActionDoubleClick"))
            {
                AssignEventHandlerToControl(writer, ctrl, "DoubleClick", ctrl.GetAttribute("ActionDoubleClick"));
            }
            else if (ctrl.HasAttribute("ActionOpenScreen"))
            {
                AssignEventHandlerToControl(writer, ctrl, "Click", "OpenScreen" + ctrl.controlName.Substring(ctrl.controlTypePrefix.Length));
                string ActionHandler =
                    "/// auto generated" + Environment.NewLine +
                    "protected void OpenScreen" + ctrl.controlName.Substring(ctrl.controlTypePrefix.Length) + "(object sender, EventArgs e)" +
                    Environment.NewLine +
                    "{" + Environment.NewLine;

                string ActionOpenScreen = ctrl.GetAttribute("ActionOpenScreen");
                ActionHandler += "    " + ActionOpenScreen + " frm = new " + ActionOpenScreen +
                                 "(this);" + Environment.NewLine;

                if (ActionOpenScreen.Contains("."))
                {
                    string namespaceOfScreen = ActionOpenScreen.Substring(0, ActionOpenScreen.LastIndexOf("."));
                    writer.Template.AddToCodelet("USINGNAMESPACES", "using " + namespaceOfScreen + ";" + Environment.NewLine, false);
                }

                // Does PropertyForSubScreens fit a property in the new screen? eg LedgerNumber
                if (FCodeStorage.HasAttribute("PropertyForSubScreens"))
                {
                    string propertyName = FCodeStorage.GetAttribute("PropertyForSubScreens");

                    if (FCodeStorage.ImplementationContains(ctrl.GetAttribute("ActionOpenScreen"), " " + propertyName + Environment.NewLine))
                    {
                        ActionHandler += "    frm." + propertyName + " = F" + propertyName + ";" + Environment.NewLine;
                    }
                }

                /*                for (string propertyName in FCodeStorage.GetFittingProperties(ctrl.GetAttribute("ActionOpenScreen")))
                 *              {
                 *                  ActionHandler += "    frm." + propertyName + " = F" + propertyName + ";" + Environment.NewLine;
                 *              }
                 */
                ActionHandler += "    frm.Show();" + Environment.NewLine;
                ActionHandler += "}" + Environment.NewLine + Environment.NewLine;

                FCodeStorage.FActionHandlers += ActionHandler;
            }

            if (ctrl.HasAttribute("Enabled"))
            {
                AddToActionEnabledEvent(writer, ctrl.GetAttribute("Enabled"), ctrl.controlName);
            }

            if (ctrl.HasAttribute("OnChange"))
            {
                AssignEventHandlerToControl(writer, ctrl,
                    GetEventNameForChangeEvent(),
                    GetEventHandlerTypeForChangeEvent(),
                    ctrl.GetAttribute("OnChange"));
            }

            if (ctrl.HasAttribute("OnEnter"))
            {
                AssignEventHandlerToControl(writer, ctrl,
                    "Enter",
                    "System.EventHandler",
                    ctrl.GetAttribute("OnEnter"));
            }

            if (ctrl.HasAttribute("OnLeave"))
            {
                AssignEventHandlerToControl(writer, ctrl,
                    "Leave",
                    "System.EventHandler",
                    ctrl.GetAttribute("OnLeave"));
            }

            if (ctrl.HasAttribute("Tooltip"))
            {
                writer.Template.AddToCodelet("INITUSERCONTROLS", "FPetraUtilsObject.SetStatusBarText(" + ctrl.controlName +
                    ", Catalog.GetString(\"" +
                    ctrl.GetAttribute("Tooltip") +
                    "\"));" + Environment.NewLine);
            }
            else if (ctrl.controlName == "grdDetails")
            {
                writer.Template.AddToCodelet("INITUSERCONTROLS", "FPetraUtilsObject.SetStatusBarText(" + ctrl.controlName +
                    ", Catalog.GetString(\"Use the mouse or navigation keys to select a data row to view or edit\"));" + Environment.NewLine);
            }
            else if (ctrl.controlName == "btnNew")
            {
                writer.Template.AddToCodelet("INITUSERCONTROLS", "FPetraUtilsObject.SetStatusBarText(" + ctrl.controlName +
                    ", Catalog.GetString(\"Click to create a new record\"));" + Environment.NewLine);
            }
            else if (ctrl.controlName == "btnDelete")
            {
                writer.Template.AddToCodelet("INITUSERCONTROLS", "FPetraUtilsObject.SetStatusBarText(" + ctrl.controlName +
                    ", Catalog.GetString(\"Click to delete the highlighted record(s)\"));" + Environment.NewLine);
            }

            //TODO: CT
//            if (ctrl.HasAttribute("DefaultValue"))
//            {
//                writer.Template.AddToCodelet("DEFAULTOVERRIDE", UndoValue(ctrl, ;
//            }

            if (ctrl.HasAttribute("PartnerShortNameLookup"))
            {
                LinkControlPartnerShortNameLookup(writer, ctrl);
            }
            else if (ctrl.HasAttribute("DataField"))
            {
                string dataField = ctrl.GetAttribute("DataField");

                TTableField field = TDataBinding.GetTableField(ctrl, dataField, out IsDetailNotMaster, true);

                LinkControlDataField(writer, ctrl, field, IsDetailNotMaster);
                DataFieldUndoCapability(writer, ctrl, field, IsDetailNotMaster);
            }
            else if (writer.CodeStorage.HasAttribute("MasterTable") || writer.CodeStorage.HasAttribute("DetailTable"))
            {
                //if (ctrl.controlTypePrefix != "lbl" && ctrl.controlTypePrefix != "pnl" && ctrl.controlTypePrefix != "grp" &&
                if (!((this is LabelGenerator) || (this is LinkLabelGenerator)))
                {
                    TTableField field = TDataBinding.GetTableField(ctrl, ctrl.controlName.Substring(
                            ctrl.controlTypePrefix.Length), out IsDetailNotMaster, false);

                    if (field != null)
                    {
                        LinkControlDataField(writer, ctrl, field, IsDetailNotMaster);
                        DataFieldUndoCapability(writer, ctrl, field, IsDetailNotMaster);
                    }
                }
            }
            else if (ctrl.controlTypePrefix == "uco")
            {
                writer.Template.AddToCodelet("SAVEDATA", ctrl.controlName + ".GetDataFromControls();" + Environment.NewLine);
                writer.Template.AddToCodelet("PRIMARYKEYCONTROLSREADONLY",
                    ctrl.controlName + ".SetPrimaryKeyReadOnly(AReadOnly);" + Environment.NewLine);

                writer.Template.AddToCodelet("USERCONTROLVALIDATION", ctrl.controlName + ".ValidateAllData(false, false);" + Environment.NewLine);
                writer.Template.SetCodelet("PERFORMUSERCONTROLVALIDATION", "true");
            }
            else if (ctrl.HasAttribute("DynamicControlType"))
            {
                writer.Template.AddToCodelet("SAVEDATA", "if(FUco" + ctrl.controlName.Substring(
                        3) + " != null)" + Environment.NewLine + "{" + Environment.NewLine +
                    "    FUco" + ctrl.controlName.Substring(3) + ".GetDataFromControls();" + Environment.NewLine + "}" + Environment.NewLine);
                writer.Template.AddToCodelet("PRIMARYKEYCONTROLSREADONLY", "if(FUco" + ctrl.controlName.Substring(
                        3) + " != null)" + Environment.NewLine + "{" + Environment.NewLine +
                    "    FUco" + ctrl.controlName.Substring(
                        3) + ".SetPrimaryKeyReadOnly(AReadOnly);" + Environment.NewLine + "}" + Environment.NewLine);
            }

            // the readonly property eg of Textbox still allows tooltips and copy to clipboard, which enable=false would not allow
            if (TYml2Xml.HasAttribute(ctrl.xmlNode, "ReadOnly")
                && (TYml2Xml.GetAttribute(ctrl.xmlNode, "ReadOnly").ToLower() == "true"))
            {
                if (FHasReadOnlyProperty)
                {
                    writer.SetControlProperty(ctrl,
                        "ReadOnly",
                        "true");
                    writer.SetControlProperty(ctrl,
                        "TabStop",
                        "false");
                }
                else
                {
                    writer.SetControlProperty(ctrl,
                        "Enabled",
                        "false");
                }
            }

            if (GenerateDataValidationCode(writer, ctrl, out AutomDataValidation, out ReasonForAutomValidation))
            {
                AssignEventHandlerToControl(writer, ctrl, "Validated", "ControlValidatedHandler");
            }
            else
            {
                bool AssignControlUpdateDataHandler = false;

                if (ctrl.HasAttribute("DataField"))
                {
                    TDataBinding.GetTableField(ctrl, ctrl.GetAttribute("DataField"), out IsDetailNotMaster, true);

                    if (IsDetailNotMaster)
                    {
                        AssignControlUpdateDataHandler = true;
                    }
                }
                else
                {
                    if (writer.CodeStorage.HasAttribute("DetailTable"))
                    {
                        if (!((this is LabelGenerator) || (this is LinkLabelGenerator)))
                        {
                            if (TDataBinding.GetTableField(ctrl, ctrl.controlName.Substring(
                                        ctrl.controlTypePrefix.Length), out IsDetailNotMaster, false) != null)
                            {
                                if (IsDetailNotMaster)
                                {
                                    AssignControlUpdateDataHandler = true;
                                }
                            }
                        }
                    }
                }

                if (AssignControlUpdateDataHandler)
                {
                    if ((!ctrl.controlTypePrefix.StartsWith("mn"))
                        && (!ctrl.controlTypePrefix.StartsWith("tb"))
                        && (ctrl.controlTypePrefix != "pnl")
                        && (ctrl.controlTypePrefix != "grp")
                        && (ctrl.controlTypePrefix != "grd")
                        && (ctrl.controlTypePrefix != "btn")
                        && (ctrl.controlTypePrefix != "stb")
                        && (ctrl.controlTypePrefix != "lbl"))
                    {
                        AssignEventHandlerToControl(writer, ctrl, "Validated", "ControlUpdateDataHandler");
                        writer.Template.SetCodelet("GENERATECONTROLUPDATEDATAHANDLER", "true");
                    }
                }
            }

            return writer.Template;
        }

        private bool GenerateDataValidationCode(TFormWriter writer, TControlDef ctrl, out bool AAutomDataValidation,
            out string AReasonForAutomValidation)
        {
            AAutomDataValidation = false;
            AReasonForAutomValidation = String.Empty;

            if ((ctrl.HasAttribute("Validation"))
                && (ctrl.GetAttribute("Validation").ToLower() != "false"))
            {
                return true;
            }

            if (TDataValidation.GenerateAutoValidationCodeForControl(ctrl,
                    ctrl.HasAttribute("DataField"),
                    (writer.CodeStorage.HasAttribute("MasterTable")
                     || writer.CodeStorage.HasAttribute("DetailTable")),
                    !((this is LabelGenerator) || (this is LinkLabelGenerator)),
                    TDataValidation.TAutomDataValidationScope.advsAll, out AReasonForAutomValidation)
                )
            {
                AAutomDataValidation = true;

                return true;
            }
            else
            {
                return false;
            }
        }

        /// <summary>
        /// fetch the partner short name from the server;
        /// this control is readonly, therefore we don't need statusbar help
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        private void LinkControlPartnerShortNameLookup(TFormWriter writer, TControlDef ctrl)
        {
            string PartnerShortNameLookup = ctrl.GetAttribute("PartnerShortNameLookup");
            bool IsDetailNotMaster;

            TTableField field = TDataBinding.GetTableField(ctrl, PartnerShortNameLookup, out IsDetailNotMaster, true);

            string showData = "TPartnerClass partnerClass;" + Environment.NewLine;
            string RowName = "FMainDS." + TTable.NiceTableName(field.strTableName) + "[0]";

            if ((TTable.NiceTableName(field.strTableName) == writer.CodeStorage.GetAttribute("DetailTable"))
                || (TTable.NiceTableName(field.strTableName) == writer.CodeStorage.GetAttribute("MasterTable")))
            {
                RowName = "ARow";
            }

            showData += "string partnerShortName;" + Environment.NewLine;
            showData += "TRemote.MPartner.Partner.ServerLookups.WebConnectors.GetPartnerShortName(" + Environment.NewLine;
            showData += "    " + RowName + "." + TTable.NiceFieldName(field.strName) + "," +
                        Environment.NewLine;
            showData += "    out partnerShortName," + Environment.NewLine;
            showData += "    out partnerClass);" + Environment.NewLine;
            showData += ctrl.controlName + ".Text = partnerShortName;" + Environment.NewLine;

            writer.Template.AddToCodelet("SHOWDATA", showData);
        }

        private void DataFieldUndoCapability(TFormWriter writer, TControlDef ctrl, TTableField AField, bool AIsDetailNotMaster)
        {
            if (AField == null)
            {
                return;
            }

            string tablename = TTable.NiceTableName(AField.strTableName);
            string fieldname = TTable.NiceFieldName(AField);
            string TestForNullTable = "FMainDS." + tablename;

            if ((tablename == writer.CodeStorage.GetAttribute("DetailTable")) || (tablename == writer.CodeStorage.GetAttribute("MasterTable")))
            {
                TestForNullTable = "";
            }

            string targetCodelet = "UNDODATA";

            ProcessTemplate snippetShowData = GenerateUndoDataSnippetCode(ref tablename, ref fieldname, ref TestForNullTable, writer, ctrl, AField);

            writer.Template.InsertSnippet(targetCodelet, snippetShowData);
        }

        private void LinkControlDataField(TFormWriter writer, TControlDef ctrl, TTableField AField, bool AIsDetailNotMaster)
        {
            ProcessTemplate snippetValidationControlsDictAdd;
            bool AutomDataValidation;
            string ReasonForAutomValidation;
            string ColumnIDStr;
            bool OKToGenerateDVCode = true;

            if (AField == null)
            {
                return;
            }

            string tablename = TTable.NiceTableName(AField.strTableName);
            string fieldname = TTable.NiceFieldName(AField);
            string RowName = "FMainDS." + tablename + "[0]";
            string TestForNullTable = "FMainDS." + tablename;

            if ((tablename == writer.CodeStorage.GetAttribute("DetailTable")) || (tablename == writer.CodeStorage.GetAttribute("MasterTable")))
            {
                RowName = "ARow";
                TestForNullTable = "";
            }

            string targetCodelet = "SHOWDATA";

            if (tablename == writer.CodeStorage.GetAttribute("DetailTable"))
            {
                targetCodelet = "SHOWDETAILS";
            }

            ProcessTemplate snippetShowData = GenerateShowDataSnippetCode(ref fieldname, ref RowName, ref TestForNullTable, writer, ctrl, AField);

            writer.Template.InsertSnippet(targetCodelet, snippetShowData);

            if (AField.bPartOfPrimKey)
            {
                // check if the current row is new; then allow changing the primary key; otherwise make the control readonly
                writer.Template.AddToCodelet(targetCodelet, ctrl.controlName + "." + (FHasReadOnlyProperty ? "ReadOnly" : "Enabled") + " = " +
                    "(" + RowName + ".RowState " + (FHasReadOnlyProperty ? "!=" : "==") + " DataRowState.Added);" + Environment.NewLine);
                writer.Template.AddToCodelet("PRIMARYKEYCONTROLSREADONLY",
                    ctrl.controlName + "." + (FHasReadOnlyProperty ? "ReadOnly = " : "Enabled = !") + "AReadOnly;" + Environment.NewLine);
            }

            if (ctrl.GetAttribute("ReadOnly").ToLower() != "true")
            {
                targetCodelet = targetCodelet.Replace("SHOW", "SAVE");

                ProcessTemplate snippetGetData = writer.Template.GetSnippet("GETDATAFORCOLUMNTHATCANBENULL");

                if (AField.GetDotNetType().ToLower().Contains("string"))
                {
                    snippetGetData.SetCodelet("GETVALUEORNULL", "{#ROW}.{#COLUMNNAME} = {#CONTROLVALUE};");
                    snippetGetData.InsertSnippet("GETROWVALUEORNULL", writer.Template.GetSnippet("GETROWVALUEORNULLSTRING"));
                }
                else
                {
                    snippetGetData.InsertSnippet("GETVALUEORNULL", writer.Template.GetSnippet("GETVALUEORNULL"));
                    snippetGetData.InsertSnippet("GETROWVALUEORNULL", writer.Template.GetSnippet("GETROWVALUEORNULL"));
                }

                snippetGetData.SetCodelet("CANBENULL", !AField.bNotNull && (this.GetControlValue(ctrl, null) != null) ? "yes" : "");
                snippetGetData.SetCodelet("NOTDEFAULTTABLE", TestForNullTable);
                snippetGetData.SetCodelet("DETERMINECONTROLISNULL", this.GetControlValue(ctrl, null));
                snippetGetData.SetCodelet("ROW", RowName);
                snippetGetData.SetCodelet("COLUMNNAME", fieldname);
                snippetGetData.SetCodelet("CONTROLVALUE", this.GetControlValue(ctrl, AField.GetDotNetType()));
                snippetGetData.SetCodelet("CONTROLNAME", ctrl.controlName);

                writer.Template.InsertSnippet(targetCodelet, snippetGetData);
            }

            // setstatusbar tooltips for datafields, with getstring plus value from petra.xml
            string helpText = AField.strHelp;

            if (helpText.Length == 0)
            {
                helpText = AField.strDescription;
            }

            if ((helpText.Length > 0) && (ctrl.GetAttribute("Tooltip").Length == 0))
            {
                writer.Template.AddToCodelet("INITUSERCONTROLS", "FPetraUtilsObject.SetStatusBarText(" + ctrl.controlName +
                    ", Catalog.GetString(\"" +
                    helpText.Replace("\"", "\\\"") +                           // properly escape double quotation marks
                    "\"));" + Environment.NewLine);
            }

            // Data Validation
            if (GenerateDataValidationCode(writer, ctrl, out AutomDataValidation, out ReasonForAutomValidation))
            {
                string targetCodeletValidation = "ADDCONTROLTOVALIDATIONCONTROLSDICT";

                ColumnIDStr = "FMainDS." + tablename + ".Columns[(short)FMainDS." + tablename + ".GetType().GetField(\"Column" + fieldname +
                              "Id\", BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy).GetValue(FMainDS." + tablename +
                              ".GetType())]";

                if (writer.Template.FCodelets.Keys.Contains(targetCodeletValidation))
                {
                    // Check if code for the addition of a certain DataColumn is is already contained in Template;
                    // if so, skip a further addition to prevent an Exception at runtime
                    if (writer.Template.FCodelets[targetCodeletValidation].ToString().Contains(ColumnIDStr))
                    {
                        OKToGenerateDVCode = false;
                    }
                }

                if (OKToGenerateDVCode)
                {
                    if (!ctrl.GetAttribute("Validation").ToLower().StartsWith("pair("))
                    {
                        snippetValidationControlsDictAdd = writer.Template.GetSnippet("VALIDATIONCONTROLSDICTADD");
                    }
                    else
                    {
                        snippetValidationControlsDictAdd = writer.Template.GetSnippet("VALIDATIONCONTROLSDICTADDMULTI");

                        string PairControlName = ctrl.GetAttribute("Validation").Substring(5, ctrl.GetAttribute("Validation").Length - 6);
                        TControlDef SecondValidationControl = writer.CodeStorage.GetControl(PairControlName);

                        if (SecondValidationControl != null)
                        {
                            snippetValidationControlsDictAdd.SetCodelet("VALIDATIONCONTROL2", SecondValidationControl.controlName);

                            if (TFormWriter.ProperI18NCatalogGetString(StringHelper.TrimQuotes(SecondValidationControl.Label)))
                            {
                                snippetValidationControlsDictAdd.SetCodelet("LABELTEXT2",
                                    "Catalog.GetString(" + "\"" + SecondValidationControl.Label + "\")");
                            }
                            else
                            {
                                snippetValidationControlsDictAdd.SetCodelet("LABELTEXT2", "\"" + SecondValidationControl.Label + "\"");
                            }
                        }
                        else
                        {
                            throw new ApplicationException(
                                "Pair Control for Validation '" + PairControlName + "' does not exist. Please specify a valid control!");
                        }
                    }

                    snippetValidationControlsDictAdd.SetCodelet("TABLENAME", tablename);
                    snippetValidationControlsDictAdd.SetCodelet("COLUMNID", ColumnIDStr);
                    snippetValidationControlsDictAdd.SetCodelet("VALIDATIONCONTROLSDICTVAR",
                        writer.Template.FTemplateCode.Contains(
                            "FValidationControlsDict") ? "FValidationControlsDict" : "FPetraUtilsObject.ValidationControlsDict");

                    if (AutomDataValidation)
                    {
                        snippetValidationControlsDictAdd.SetCodelet("AUTOMATICVALIDATIONCOMMENT",
                            " // Automatic Data Validation based on DB specification: " + ReasonForAutomValidation);
                    }
                    else
                    {
                        snippetValidationControlsDictAdd.SetCodelet("AUTOMATICVALIDATIONCOMMENT", "");
                    }

                    snippetValidationControlsDictAdd.SetCodelet("VALIDATIONCONTROL", ctrl.controlName);

                    if (TFormWriter.ProperI18NCatalogGetString(StringHelper.TrimQuotes(ctrl.Label)))
                    {
                        snippetValidationControlsDictAdd.SetCodelet("LABELTEXT", "Catalog.GetString(" + "\"" + ctrl.Label + "\")");
                    }
                    else
                    {
                        snippetValidationControlsDictAdd.SetCodelet("LABELTEXT", "\"" + ctrl.Label + "\"");
                    }

                    writer.Template.InsertSnippet(targetCodeletValidation, snippetValidationControlsDictAdd);
                }
            }
        }

        /// <summary>
        /// Generates code for the SHOWDATA Snippet.
        /// </summary>
        /// <param name="fieldname">Name of field</param>
        /// <param name="RowName">Name of row</param>
        /// <param name="TestForNullTable"></param>
        /// <param name="writer">FormWriter instance.</param>
        /// <param name="ctrl">TControlDef instance.</param>
        /// <param name="AField">TTableField instance.</param>
        /// <returns>A <see cref="ProcessTemplate"></see>.</returns>
        ProcessTemplate GenerateShowDataSnippetCode(ref string fieldname,
            ref string RowName,
            ref string TestForNullTable,
            TFormWriter writer,
            TControlDef ctrl,
            TTableField AField)
        {
            ProcessTemplate snippetShowData = writer.Template.GetSnippet("SHOWDATAFORCOLUMN");

            if (AField.GetDotNetType().ToLower().Contains("string"))
            {
                snippetShowData.SetCodelet("SETVALUEORNULL", "{#SETCONTROLVALUE}");
                snippetShowData.SetCodelet("SETROWVALUEORNULL", "{#SETROWVALUE}");
            }
            else
            {
                snippetShowData.InsertSnippet("SETVALUEORNULL", writer.Template.GetSnippet("SETVALUEORNULL"));
                snippetShowData.InsertSnippet("SETROWVALUEORNULL", writer.Template.GetSnippet("SETROWVALUEORNULL"));
            }

            snippetShowData.SetCodelet("CANBENULL", !AField.bNotNull ? "yes" : "");
            snippetShowData.SetCodelet("DETERMINECONTROLISNULL", this.GetControlValue(ctrl, null));
            snippetShowData.SetCodelet("NOTDEFAULTTABLE", TestForNullTable);
            snippetShowData.SetCodelet("ROW", RowName);
            snippetShowData.SetCodelet("COLUMNNAME", fieldname);
            snippetShowData.SetCodelet("SETNULLVALUE", this.AssignValue(ctrl, null, null));
            snippetShowData.SetCodelet("SETCONTROLVALUE", this.AssignValue(ctrl, RowName + "." + fieldname, AField.GetDotNetType()));
            snippetShowData.InsertSnippet("SETROWVALUE", writer.Template.GetSnippet("SETROWVALUE"));

            return snippetShowData;
        }

        /// <summary>
        /// Generates code for the UNDODATA Snippet.
        /// </summary>
        /// <param name="tablename">Name of table</param>
        /// <param name="fieldname">Name of field</param>
        /// <param name="TestForNullTable"></param>
        /// <param name="writer">FormWriter instance.</param>
        /// <param name="ctrl">TControlDef instance.</param>
        /// <param name="AField">TTableField instance.</param>
        /// <returns>A <see cref="ProcessTemplate"></see>.</returns>
        ProcessTemplate GenerateUndoDataSnippetCode(ref string tablename,
            ref string fieldname,
            ref string TestForNullTable,
            TFormWriter writer,
            TControlDef ctrl,
            TTableField AField)
        {
            ProcessTemplate snippetShowData = writer.Template.GetSnippet("UNDODATAFORCOLUMN");

            snippetShowData.SetCodelet("NOTDEFAULTTABLE", TestForNullTable);

            snippetShowData.SetCodelet("UNDOCONTROLVALUE",
                this.UndoValue(ctrl, "ARow[FMainDS." + tablename + ".Columns[(short)FMainDS." + tablename + ".GetType().GetField(\"Column" +
                    fieldname +
                    "Id\", BindingFlags.Public | BindingFlags.Static | BindingFlags.FlattenHierarchy).GetValue(FMainDS." + tablename +
                    ".GetType())], DataRowVersion.Original]",
                    AField.GetDotNetType()));
            snippetShowData.InsertSnippet("UNDOROWVALUE", writer.Template.GetSnippet("UNDOROWVALUE"));

            snippetShowData.SetCodelet("CONTROLNAME", ctrl.controlName);

            return snippetShowData;
        }

        /// <summary>
        /// Sets the properties of a control which are defined under "Actions:" in the .yaml file
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="ctrl"></param>
        /// <param name="AActionHandler"></param>
        public virtual void SetControlActionProperties(TFormWriter writer, TControlDef ctrl, TActionHandler AActionHandler)
        {
            if (AActionHandler.actionImage.Length > 0)
            {
                /* Get the name of the image for the toolbar button
                 * and put it into the resources.
                 * The images must be in the directory specified by the ResourceDir command line parameter
                 */
                writer.SetControlProperty(ctrl, "Image",
                    "((System.Drawing.Bitmap)resources" + ctrl.controlType + ".GetObject(\"" + ctrl.controlName + ".Glyph\"))");
                writer.AddImageToResource(ctrl.controlName, AActionHandler.actionImage, "Bitmap");
            }

            if ((AActionHandler.actionTooltip.Length > 0) && (ctrl.controlTypePrefix != "btn"))
            {
                writer.SetControlProperty(ctrl, "ToolTipText", "\"" + AActionHandler.actionTooltip + "\"");
            }
        }

        /// <summary>
        /// write code for on change event
        /// </summary>
        public virtual void OnChangeDataType(TFormWriter writer, XmlNode curNode)
        {
            OnChangeDataType(writer, curNode, curNode.Name);
        }

        /// <summary>
        /// write code for on change event
        /// </summary>
        public virtual void OnChangeDataType(TFormWriter writer, XmlNode curNode, string controlName)
        {
            // the selection of this control triggers the available options in other controls
            if (TYml2Xml.HasAttribute(curNode, "OnChangeDataType"))
            {
                writer.Template.AddToCodelet("CONTROLINITIALISATION",
                    "this." + controlName + ".Leave += new EventHandler(this." + StringHelper.UpperCamelCase(controlName,
                        ',',
                        false,
                        false) + "_SelectionChangeCommitted);" + Environment.NewLine +
                    "this." + controlName + ".SelectionChangeCommitted += new EventHandler(this." +
                    StringHelper.UpperCamelCase(controlName, ',', false, false) + "_SelectionChangeCommitted);" + Environment.NewLine);
                writer.CodeStorage.FEventHandlersImplementation +=
                    "private void " +
                    StringHelper.UpperCamelCase(controlName, ',', false,
                        false) + "_SelectionChangeCommitted(System.Object sender, System.EventArgs e)" + Environment.NewLine +
                    "{" + Environment.NewLine +
                    "  " +
                    StringHelper.UpperCamelCase(controlName, ',', false,
                        false) + "_Initialise(" + controlName + ".GetSelected" + TYml2Xml.GetAttribute(
                        curNode,
                        "OnChangeDataType") + "());" + Environment.NewLine +
                    "}" + Environment.NewLine + Environment.NewLine;
                writer.CodeStorage.FEventHandlersImplementation +=
                    "private void " + StringHelper.UpperCamelCase(controlName, ',', false, false) + "_Initialise(" + TYml2Xml.GetAttribute(curNode,
                        "OnChangeDataType") + " AParam)" + Environment.NewLine +
                    "{" + Environment.NewLine +
                    "  Int32 Index;" + Environment.NewLine +
                    "  Index = this." + controlName + ".Find" +
                    TYml2Xml.GetAttribute(curNode, "OnChangeDataType") + "InComboBox(AParam);" + Environment.NewLine +
                    "  if ((Index >= 0) && (Index < this." + controlName + ".Items.Count) && (Index != this." + controlName + ".SelectedIndex)) " +
                    Environment.NewLine +
                    "  {" + Environment.NewLine +
                    "    this." + controlName + ".SelectedIndex = Index;" + Environment.NewLine +
                    "  }" + Environment.NewLine +
                    "  {#INITIALISE_" + controlName + "}" + Environment.NewLine +
                    "}" + Environment.NewLine + Environment.NewLine;
            }
        }

        /// e.g. used for controls on Reports (readparameter, etc)
        public virtual void ApplyDerivedFunctionality(TFormWriter writer, TControlDef control)
        {
        }
    }

    /// <summary>
    /// this is used for checkboxes and radio button which have other controls dependant on them
    /// </summary>
    public class TControlWithDependantControlsGenerator : TControlGenerator
    {
        /// <summary>
        /// constructor
        /// </summary>
        public TControlWithDependantControlsGenerator(string APrefix, Type AControlType)
            : base(APrefix, AControlType)
        {
        }

        /// <summary>
        /// generate the children, and write the size of this control
        /// </summary>
        public override void ProcessChildren(TFormWriter writer, TControlDef ctrl)
        {
            XmlNode Controls = TXMLParser.GetChild(ctrl.xmlNode, "Controls");

            if (Controls != null)
            {
                StringCollection childControls = TYml2Xml.GetElements(Controls);

                // this is a checkbox that enables another control or a group of controls
                ctrl.SetAttribute("GenerateWithOtherControls", "yes");

                if (childControls.Count == 1)
                {
                    TControlDef ChildCtrl = ctrl.FCodeStorage.GetControl(childControls[0]);
                    ChildCtrl.parentName = ctrl.controlName;
                    ctrl.Children.Add(ChildCtrl);

                    ChildCtrl.SetAttribute("DependsOnRadioButton", "true");

                    // use the label of the child control
                    if (ChildCtrl.HasAttribute("Label"))
                    {
                        ctrl.Label = ChildCtrl.Label;
                    }
                }
                else
                {
                    foreach (string child in childControls)
                    {
                        TControlDef ChildCtrl = ctrl.FCodeStorage.GetControl(child);

                        if (ChildCtrl == null)
                        {
                            throw new Exception("cannot find control " + child + " which should belong to " + ctrl.controlName);
                        }

                        ChildCtrl.parentName = ctrl.controlName;
                        ctrl.Children.Add(ChildCtrl);

                        ChildCtrl.SetAttribute("DependsOnRadioButton", "true");

                        IControlGenerator ctrlGenerator = writer.FindControlGenerator(ChildCtrl);
                        ctrlGenerator.GenerateControl(writer, ChildCtrl);
                    }
                }
            }
        }

        /// add and install event handler for change of selection
        public override ProcessTemplate SetControlProperties(TFormWriter writer, TControlDef ctrl)
        {
            base.SetControlProperties(writer, ctrl);

            writer.Template.AddToCodelet("CHECKEDCHANGED_" + ctrl.controlName, string.Empty);

            foreach (TControlDef ChildCtrl in ctrl.Children)
            {
                // make sure the control is enabled/disabled depending on the selection of the radiobutton
                writer.Template.AddToCodelet("CHECKEDCHANGED_" + ctrl.controlName,
                    ChildCtrl.controlName + ".Enabled = " + ctrl.controlName + ".Checked;" + Environment.NewLine);
            }

            writer.CodeStorage.FEventHandlersImplementation += "void " + ctrl.controlName + "CheckedChanged(object sender, System.EventArgs e)" +
                                                               Environment.NewLine + "{" + Environment.NewLine + "  {#CHECKEDCHANGED_" +
                                                               ctrl.controlName + "}" + Environment.NewLine +
                                                               "}" + Environment.NewLine + Environment.NewLine;
            writer.Template.AddToCodelet("INITIALISESCREEN", ctrl.controlName + "CheckedChanged(null, null);" + Environment.NewLine);
            writer.Template.AddToCodelet("CONTROLINITIALISATION",
                "this." + ctrl.controlName +
                ".CheckedChanged += new System.EventHandler(this." +
                ctrl.controlName +
                "CheckedChanged);" + Environment.NewLine);
            writer.Template.AddToCodelet("INITACTIONSTATE", ctrl.controlName + "CheckedChanged(null, null);" + Environment.NewLine);

            return writer.Template;
        }
    }
}