// Copyright (c) 2013 Mark Pearce
// http://opensource.org/licenses/MIT

using System;
using System.Globalization;
using System.Collections.Generic;

namespace PasswordUtilities
{
/// <summary>
/// This class estimates the information entropy and
/// strength of a specific password and/or password hash.
/// </summary>
internal sealed class EntropyChecker
{
    // The symbol types used within the password - these are used to make an educated
    // guess about the password entropy when we don't know the password policy.
    private const string ASCII_LOWERCASE = "abcdefghijklmnopqrstuvwxyz";
    private const string ASCII_UPPERCASE = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    private const string ASCII_NUMERIC = "0123456789";
    private const string ASCII_OTHER = @"| £""()[]{}<>!;:,.'?*$-+_&=%/\^~#@";
    // This is a pure guess. If we don't know the password policy, there's no way
    // we can know what range of non-ASCII symbols was used to generate the password.
    private const int NON_ASCII_LENGTH = 100;
    // Collection of above character sets used to analyse password without policy.
    private static readonly Dictionary <String, CharacterSet>CHARACTER_SETS = new Dictionary <String, CharacterSet>();

    // The entry point (in bits of entropy) for each
    // of the password strength ranges.
    private const double ADEQUATE_ENTRY_POINT = 30.0;
    private const double STRONG_ENTRY_POINT = 60.0;
    private const double VERY_STRONG_ENTRY_POINT = 80.0;

    // Entropy calculator for a password generated by a human.
    // This applies a NIST formula based solely on the password length.
    private readonly double[] NIST_HUMAN_ENTROPY =
    {
        0, 4, 6, 8, 10, 12, 14, 16, 18, 19.5, 21, 22.5, 24, 25.5, 27, 28.5, 30, 31.5, 33, 34.5, 36
    };
    private readonly int NIST_CUTOFF;
    private readonly double NIST_HIGH;

    // Private representation of public property.
    private double m_PasswordEntropy;

    /// <summary>
    /// Default constructor.
    /// </summary>
    public EntropyChecker()
    {
        // NIST formula constants.
        NIST_CUTOFF = NIST_HUMAN_ENTROPY.Length - 1;
        NIST_HIGH = NIST_HUMAN_ENTROPY[NIST_CUTOFF];

        if (CHARACTER_SETS.Count == 0)
        {
            CHARACTER_SETS.Add("AL", new CharacterSet("AL", "ASCII lowercase", ASCII_LOWERCASE));
            CHARACTER_SETS.Add("AU", new CharacterSet("AU", "ASCII uppercase", ASCII_UPPERCASE));
            CHARACTER_SETS.Add("AN", new CharacterSet("AN", "ASCII numeric", ASCII_NUMERIC));
            CHARACTER_SETS.Add("AO", new CharacterSet("AO", "ASCII other", ASCII_OTHER));
        }
    }

    /// <summary>
    /// Specified password as a Unicode string.
    /// </summary>
    public string Password {
        get; private set;
    }

    /// <summary>
    /// The password's estimated entropy in bits to 3 decimal places.
    /// </summary>
    public double PasswordEntropy
    {
        get
        {
            return Math.Round(m_PasswordEntropy, 3);
        }
        private set
        {
            m_PasswordEntropy = value;
        }
    }

    /// <summary>
    /// The password's estimated strength based on its entropy.
    /// </summary>
    /// <remarks>
    /// This is a bit of a guesstimate - I can't find an accurate formula.
    /// In 1998, the EFF cracked a 56-bit key in 56 hours using specialised FPGA hardware.
    /// In 2002, distributed.net cracked a 64-bit key in 4 years, 9 months, and 23 days.
    /// In August 2010, distributed.net estimated that cracking a 72-bit key using
    /// current hardware would take about 48,712 days or 133.5 years.
    /// NIST recommends 80 bits for the most secure passwords.
    /// 256 bits will never be broken by any combination of digital computers.
    /// For more details, see http://en.wikipedia.org/wiki/Password_strength
    /// </remarks>
    public PasswordStrength PasswordEstimatedStrength
    {
        get
        {
            if (this.PasswordEntropy < ADEQUATE_ENTRY_POINT)
            {
                return PasswordStrength.Weak;
            }
            else if (this.PasswordEntropy < STRONG_ENTRY_POINT)
            {
                return PasswordStrength.Adequate;
            }
            else if (this.PasswordEntropy < VERY_STRONG_ENTRY_POINT)
            {
                return PasswordStrength.Strong;
            }
            else
            {
                return PasswordStrength.VeryStrong;
            }
        }
    }

    /// <summary>
    /// Estimates the added entropy added to a password by
    /// password stretching using hash iterations.
    /// </summary>
    /// <param name="numberOfHashIterations">
    /// The number of iterations used to produce the final hash.
    /// </param>
    /// <returns>
    /// The added entropy in bits. According to Moore's Law, each
    /// extra bit of entropy will take an extra 18 months to
    /// crack the password hash at the same speed as today.
    /// </returns>
    public double HashEntropy(int numberOfHashIterations)
    {
        return Math.Log(numberOfHashIterations, 2);
    }

    /// <summary>
    /// Estimates the entropy of a random password generated
    /// by a machine where the password policy is known.
    /// </summary>
    /// <param name="passwordPolicy">
    /// The policy used to generate the password.
    /// </param>
    /// <param name="passwordLength">
    /// The lenth of the password to be measured.
    /// </param>
    /// <remarks>
    /// Where the password policy is known, we only need the policy
    /// and the password length to calculate the password entropy.
    /// The formula is L * (log N / log 2), where L is the password length
    /// and N is the policy-defined average number of symbols used to generate
    /// each password character.
    /// For more details, see http://en.wikipedia.org/wiki/Password_strength
    /// </remarks>
    /// <returns>
    /// The password's estimated entropy in bits to 3 decimal places.
    /// </returns>
    public double MachinePasswordPolicyKnown(PasswordPolicy passwordPolicy, int passwordLength)
    {
        this.ValidateParameters(passwordPolicy, passwordLength);

        if (passwordLength == 0)
        {
            this.PasswordEntropy = 0;
        }
        else
        {
            double averageSymbolCount = AverageSymbolsPerCharacter(passwordPolicy, passwordLength);
            this.PasswordEntropy = passwordLength * Math.Log(averageSymbolCount, 2);
        }

        return this.PasswordEntropy;
    }

    /// <summary>
    /// Estimates the entropy of a random password generated
    /// by a machine where the password policy is unknown.
    /// </summary>
    /// <param name="password">
    /// The password to be measured as a Unicode string.
    /// </param>
    /// <remarks>
    /// Where the password policy is unknown, we analyse the symbols used to
    /// form the password, then make an educated guess about how many symbols
    /// were used to generate each of the password characters.
    /// The formula is L * (log N / log 2), where L is the password length
    /// and N is the estimated average number of symbols used to generate
    /// each password character.
    /// For more details, see http://en.wikipedia.org/wiki/Password_strength
    /// </remarks>
    /// <returns>
    /// The password's estimated entropy in bits to 3 decimal places.
    /// </returns>
    public double MachinePasswordPolicyUnknown(string password)
    {
        this.ValidateParameters(password);
        this.Password = password;

        if (Password.Length == 0)
        {
            this.PasswordEntropy = 0;
        }
        else
        {
            double averageSymbolCount = AverageSymbolsPerCharacter(password);
            this.PasswordEntropy = password.Length * Math.Log(averageSymbolCount, 2);
        }

        return this.PasswordEntropy;
    }

    /// <summary>
    /// Estimates the entropy of a password generated by a human.
    /// </summary>
    /// <param name="password">
    /// The password to be measured as a Unicode string.
    /// </param>
    /// <remarks>
    /// A password generated by a human is always weaker than a random password.
    /// Users rarely make full use of larger characters sets in forming passwords.
    /// For example, hacking results obtained from a MySpace phishing scheme in
    /// 2006 revealed 34,000 passwords. Only 8.3% used mixed case, numbers, and
    /// symbols. The most common password was "password"!
    /// </remarks>
    /// <returns>
    /// The password's estimated entropy in bits to 3 decimal places.
    /// This applies a NIST formula based solely on the password length.
    /// </returns>
    public double HumanPassword(string password)
    {
        this.ValidateParameters(password);
        this.Password = password;
        this.PasswordEntropy = this.CalculateHumanEntropy(password.Length);
        return this.PasswordEntropy;
    }

    // Validate parameters of public methods.
    private void ValidateParameters(PasswordPolicy passwordPolicy, int passwordLength)
    {
        if (passwordPolicy == null)
        {
            throw new ArgumentNullException("passwordPolicy", String.Format(CultureInfo.InvariantCulture, "Password policy cannot be null"));
        }

        if (passwordLength < 0)
        {
            throw new ArgumentOutOfRangeException("passwordLength",
                String.Format(CultureInfo.InvariantCulture, "Password length must be at least zero"));
        }
    }

    // Validate parameters of public methods.
    private void ValidateParameters(string password)
    {
        if (password == null)
        {
            throw new ArgumentNullException("password", String.Format(CultureInfo.InvariantCulture, "Password cannot be null"));
        }
    }

    // Used for a password generated by a human.
    // This applies a NIST formula based solely on the password length.
    private double CalculateHumanEntropy(int passwordLength)
    {
        double bitsOfEntropy = 0;

        if (passwordLength > NIST_CUTOFF)
        {
            // Example: 21-character password = 36 + 21 - 20 = 37
            bitsOfEntropy = NIST_HIGH + passwordLength - NIST_CUTOFF;
        }
        else
        {
            // Example: 15-character password = NIST_HUMAN_ENTROPY[15] = 28.5
            bitsOfEntropy = NIST_HUMAN_ENTROPY[passwordLength];
        }

        return bitsOfEntropy;
    }

    // Calculate the average number of symbols used to generate
    // each password character, using the specified password policy.
    private static double AverageSymbolsPerCharacter(PasswordPolicy passwordPolicy, Int32 passwordLength)
    {
        double symbolCount = 0;

        // First calculate minimum number of symbols.
        foreach (CharacterSet characterSet in passwordPolicy.AllowedCharacterSets)
        {
            symbolCount += characterSet.MinimumNumberOfCharacters * characterSet.Characters.Length;
        }

        // All remaining symbols are taken from the full range allowed.
        symbolCount += (passwordLength - passwordPolicy.MinimumNumberOfSymbols) * passwordPolicy.AllowedSymbols.Length;

        return Math.Round((symbolCount / passwordLength), 3);
    }

    // Estimate the average number of symbols used to generate
    // each password character where the password policy isn't known.
    private static double AverageSymbolsPerCharacter(string password)
    {
        double symbolCount = 0;

        List <bool>symbolFound = new List <bool>(password.Length);

        // Add to number of possible symbols for each character
        // set included in the specified password.
        foreach (CharacterSet characterSet in CHARACTER_SETS.Values)
        {
            for (Int32 i = 0; i < password.Length; i++)
            {
                if (characterSet.Characters.Contains(password[i].ToString()))
                {
                    symbolCount += characterSet.Characters.Length;
                    symbolFound[i] = true;
                    break;
                }
            }
        }

        // If any password characters weren't found, assume non-ASCII symbols included.
        if (symbolFound.Contains(false))
        {
            symbolCount += NON_ASCII_LENGTH;
        }

        return Math.Round((symbolCount / password.Length), 3);
    }

    /// <summary>
    /// Overrides the default ToString().
    /// </summary>
    /// <returns>
    /// The password entropy in bits.
    /// </returns>
    public override string ToString()
    {
        return String.Concat("EntropyChecker: ", this.PasswordEntropy.ToString(CultureInfo.InvariantCulture));
    }
}
}