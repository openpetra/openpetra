<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PasswordUtilities</name>
    </assembly>
    <members>
        <member name="T:PasswordUtilities.CharacterSet">
            <summary>
            Represents a set of characters that can be used to create a password.
            </summary>
        </member>
        <member name="M:PasswordUtilities.CharacterSet.#ctor(System.String,System.String,System.String)">
            <summary>
            Validate and create as an optional character set.
            </summary>
        </member>
        <member name="M:PasswordUtilities.CharacterSet.#ctor(System.String,System.String,System.String,System.Int32)">
            <summary>
            Validate and create as a mandatory character set.
            </summary>
        </member>
        <member name="P:PasswordUtilities.CharacterSet.Key">
            <summary>
            The key to be used to retrieve this character set.
            </summary>
        </member>
        <member name="P:PasswordUtilities.CharacterSet.Title">
            <summary>
            The user-friendly title of this character set.
            </summary>
        </member>
        <member name="P:PasswordUtilities.CharacterSet.Characters">
            <summary>
            The characters that make up this character set.
            </summary>
        </member>
        <member name="P:PasswordUtilities.CharacterSet.MinimumNumberOfCharacters">
            <summary>
            The characters that make up this character set.
            </summary>
        </member>
        <member name="T:PasswordUtilities.HashAlgorithm">
            <summary>
            List of password hash algorithms.
            </summary>
            <remarks>
            Only SHA-1 and SHA-2 are currently implemented.
            </remarks>
        </member>
        <member name="F:PasswordUtilities.HashAlgorithm.SHA1_160">
            <summary>
            SHA-1 has a 160-bit message digest.
            </summary>
            <remarks>
            There is an interesting collision attack 
            against SHA-1, but this has no implication 
            for password storage.
            </remarks>
        </member>
        <member name="F:PasswordUtilities.HashAlgorithm.SHA2_256">
            <summary>
            SHA-2/256 has a 256-bit digest.
            </summary>
        </member>
        <member name="F:PasswordUtilities.HashAlgorithm.SHA3_512">
            <summary>
            SHA-3/512 (Keccak) has a 512-bit digest.
            </summary>
            <remarks>
            512 bits needs 64-bit arithmetic, which is
            fine for a CPU but not for current GPUs.
            </remarks>
        </member>
        <member name="F:PasswordUtilities.HashAlgorithm.BCRYPT_192">
            <summary>
            BCRYPT has a 192-bit message digest, but can only 
            handle a maximum of 55 password characters. 
            </summary>
            <remarks>
            It's based on Blowfish rather than the SHA-X 
            algorithms. It's designed to be computationally 
            intensive and specifically slower on a GPU than 
            the combination of SHA-X + PBKDF2.
            It uses a 128-bit salt encoded in a Unix-specific
            Base64 format.
            </remarks>
        </member>
        <member name="F:PasswordUtilities.HashAlgorithm.SCRYPT_512">
            <summary>
            In this library SCRYPT has a 512-bit message digest.
            </summary>
            <remarks>
            It's based on PKDBF2 and SALSA80, but designed 
            to be difficult to attack with GPUs or FPGAs. 
            It's tweakable to be either computationally-intensive,
            memory-intensive, or both.
            </remarks>
        </member>
        <member name="T:PasswordUtilities.Die">
            <summary>
            This class generates cryptographically-strong
            pseudo-random numbers within a specified range.
            </summary>
            <remarks>
            With current implementation, the die 
            can have between 1 and 255 sides.  
            </remarks>
        </member>
        <member name="M:PasswordUtilities.Die.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:PasswordUtilities.Die.#ctor(System.Int32)">
            <summary>
            Constructor specifying number of sides.
            </summary>
        </member>
        <member name="M:PasswordUtilities.Die.Roll">
            <summary>
            Rolls the die using CSPRNG with modulo.
            </summary>
            <returns>
            An integer between 1 and the die's number of sides.
            </returns>
            <remarks>
            This uses the modulo operation to convert a cryptographically-secure
            pseudo-random byte into an integer within the required range 
            (between 1 and the number of die sides). The modulo operation is fast,
            but creates a bias. The FairRollLimit check removes the modulo bias.
            </remarks>
        </member>
        <member name="M:PasswordUtilities.Die.ToString">
            <summary>
            Overrides the default ToString().
            </summary>
            <returns>
            The result of the last roll of the die. 
            </returns>
        </member>
        <member name="M:PasswordUtilities.Die.Dispose">
            <summary>
            Implements IDisposable.
            </summary>
            <remarks>
            Don't make this method virtual. A derived type should 
            not be able to override this method.
            Because this type only disposes managed resources, it 
            don't need a finaliser. A finaliser isn't allowed to 
            dispose managed resources.
            Without a finaliser, this type doesn't need an internal 
            implementation of Dispose() and doesn't need to suppress 
            finalisation to avoid race conditions. So the full 
            IDisposable code pattern isn't required.
            </remarks>
        </member>
        <member name="P:PasswordUtilities.Die.NumberOfSides">
            <summary>
            The number of sides of this die - must be between 1 and 255.
            </summary>
            <returns>
            An integer between 1 and 255 representing the number of die sides.
            </returns>
        </member>
        <member name="P:PasswordUtilities.Die.FairRollLimit">
            <summary>
            Calculate the maximum roll result that avoids modulo bias.
            </summary>
            <remarks>
            This property removes the modulo bias. For more details, see 
            http://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
            There are Byte.MaxValue / NumberSides complete sets that can appear
            in a single byte. For instance, if we have a 6-sided die, there are
            42 full sets of 1-6 that come up. The 43rd set is incomplete.
            </remarks>
            <returns>
            The maximum roll result that avoids modulo bias.
            </returns>
        </member>
        <member name="P:PasswordUtilities.Die.RollResult">
            <summary>
            The result from the previous roll of the die.
            </summary>
            <returns>
            An integer between 1 and the number of die sides.
            </returns>
        </member>
        <member name="P:PasswordUtilities.Die.Disposed">
            <summary>
            Has this type been disposed already?
            </summary>
        </member>
        <member name="T:PasswordUtilities.EntropyChecker">
            <summary>
            This class estimates the information entropy and
            strength of a specific password and/or password hash.
            </summary>
        </member>
        <member name="M:PasswordUtilities.EntropyChecker.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:PasswordUtilities.EntropyChecker.HashEntropy(System.Int32)">
            <summary>
            Estimates the added entropy added to a password by
            password stretching using hash iterations.
            </summary>
            <param name="numberOfHashIterations">
            The number of iterations used to produce the final hash.
            </param>
            <returns>
            The added entropy in bits. According to Moore's Law, each
            extra bit of entropy will take an extra 18 months to
            crack the password hash at the same speed as today.
            </returns>
        </member>
        <member name="M:PasswordUtilities.EntropyChecker.MachinePasswordPolicyKnown(PasswordUtilities.PasswordPolicy,System.Int32)">
            <summary>
            Estimates the entropy of a random password generated
            by a machine where the password policy is known.
            </summary>
            <param name="passwordPolicy">
            The policy used to generate the password.
            </param>
            <param name="passwordLength">
            The lenth of the password to be measured.
            </param>
            <remarks>
            Where the password policy is known, we only need the policy
            and the password length to calculate the password entropy.
            The formula is L * (log N / log 2), where L is the password length 
            and N is the policy-defined average number of symbols used to generate 
            each password character. 
            For more details, see http://en.wikipedia.org/wiki/Password_strength
            </remarks>
            <returns>
            The password's estimated entropy in bits to 3 decimal places. 
            </returns>
        </member>
        <member name="M:PasswordUtilities.EntropyChecker.MachinePasswordPolicyUnknown(System.String)">
            <summary>
            Estimates the entropy of a random password generated
            by a machine where the password policy is unknown.
            </summary>
            <param name="password">
            The password to be measured as a Unicode string.
            </param>
            <remarks>
            Where the password policy is unknown, we analyse the symbols used to
            form the password, then make an educated guess about how many symbols
            were used to generate each of the password characters.
            The formula is L * (log N / log 2), where L is the password length 
            and N is the estimated average number of symbols used to generate 
            each password character. 
            For more details, see http://en.wikipedia.org/wiki/Password_strength
            </remarks>
            <returns>
            The password's estimated entropy in bits to 3 decimal places. 
            </returns>
        </member>
        <member name="M:PasswordUtilities.EntropyChecker.HumanPassword(System.String)">
            <summary>
            Estimates the entropy of a password generated by a human.
            </summary>
            <param name="password">
            The password to be measured as a Unicode string.
            </param>
            <remarks>
            A password generated by a human is always weaker than a random password.
            Users rarely make full use of larger characters sets in forming passwords. 
            For example, hacking results obtained from a MySpace phishing scheme in 
            2006 revealed 34,000 passwords. Only 8.3% used mixed case, numbers, and 
            symbols. The most common password was "password"!
            </remarks>
            <returns>
            The password's estimated entropy in bits to 3 decimal places. 
            This applies a NIST formula based solely on the password length.
            </returns>
        </member>
        <member name="M:PasswordUtilities.EntropyChecker.ToString">
            <summary>
            Overrides the default ToString().
            </summary>
            <returns>
            The password entropy in bits. 
            </returns>
        </member>
        <member name="P:PasswordUtilities.EntropyChecker.Password">
            <summary>
            Specified password as a Unicode string.
            </summary>
        </member>
        <member name="P:PasswordUtilities.EntropyChecker.PasswordEntropy">
            <summary>
            The password's estimated entropy in bits to 3 decimal places. 
            </summary>
        </member>
        <member name="P:PasswordUtilities.EntropyChecker.PasswordEstimatedStrength">
            <summary>
            The password's estimated strength based on its entropy. 
            </summary>
            <remarks>
            This is a bit of a guesstimate - I can't find an accurate formula.
            In 1998, the EFF cracked a 56-bit key in 56 hours using specialised FPGA hardware.
            In 2002, distributed.net cracked a 64-bit key in 4 years, 9 months, and 23 days.
            In August 2010, distributed.net estimated that cracking a 72-bit key using 
            current hardware would take about 48,712 days or 133.5 years.
            NIST recommends 80 bits for the most secure passwords.
            256 bits will never be broken by any combination of digital computers.
            For more details, see http://en.wikipedia.org/wiki/Password_strength
            </remarks>
        </member>
        <member name="T:PasswordUtilities.HashPolicy">
            <summary>
            Policy used to control generation of a randomly-salted password hash.
            </summary>
        </member>
        <member name="M:PasswordUtilities.HashPolicy.#ctor">
            <summary>
            Use the default hash policy settings.
            </summary>
        </member>
        <member name="M:PasswordUtilities.HashPolicy.#ctor(PasswordUtilities.HashAlgorithm)">
            <summary>
            Constructor for a non-default hash policy.
            </summary>
            <param name="hashAlgorithm">
            Required hash algorithm.
            </param>
        </member>
        <member name="M:PasswordUtilities.HashPolicy.#ctor(PasswordUtilities.HashAlgorithm,System.Int32)">
            <summary>
            Constructor for a non-default hash policy.
            </summary>
            <param name="hashAlgorithm">
            Required hash algorithm.
            </param>
            <param name="workFactor">
            Number of hash iterations expressed as 2^WorkFactor.
            </param>
        </member>
        <member name="M:PasswordUtilities.HashPolicy.#ctor(PasswordUtilities.HashAlgorithm,System.Int32,PasswordUtilities.StorageFormat)">
            <summary>
            Constructor for a non-default hash policy.
            </summary>
            <param name="hashAlgorithm">
            Required hash algorithm.
            </param>
            <param name="workFactor">
            Number of hash iterations expressed as 2^WorkFactor.
            </param>
            <param name="storageFormat">
            Storage encoding required.
            </param>
        </member>
        <member name="M:PasswordUtilities.HashPolicy.#ctor(PasswordUtilities.HashAlgorithm,System.Int32,PasswordUtilities.StorageFormat,System.Int32)">
            <summary>
            Constructor for a non-default hash policy.
            </summary>
            <param name="hashAlgorithm">
            Required hash algorithm.
            </param>
            <param name="workFactor">
            Number of hash iterations expressed as 2^WorkFactor.
            </param>
            <param name="storageFormat">
            Storage encoding required.
            </param>
            <param name="numberOfSaltBytes">
            Number of salt bytes required.
            </param>
        </member>
        <member name="M:PasswordUtilities.HashPolicy.ToString">
            <summary>
            Overrides the default ToString().
            </summary>
            <returns>
            The work factor and storage format specified by this policy. 
            </returns>
        </member>
        <member name="P:PasswordUtilities.HashPolicy.HashMethod">
            <summary>
            Required hash algorithm.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashPolicy.WorkFactor">
            <summary>
            Number of hash iterations expressed as 2^WorkFactor.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashPolicy.HashStorageFormat">
            <summary>
            Format in which to output encoded salt/hash for storage.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashPolicy.NumberOfSaltBytes">
            <summary>
            Required length of salt in bytes.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashPolicy.MinimumNumberOfSaltBytes">
            <summary>
            Minimum length of salt in bytes.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashPolicy.HashEntropy">
            <summary>
            Estimates the added entropy added to the password by this hash.
            </summary>
            <returns>
            The hash entropy in bits. 
            </returns>
        </member>
        <member name="T:PasswordUtilities.HashStorage">
            <summary>
            This class lets you encode a password hash and accompanying info for storage.
            It also lets you decode a stored password hash and accompanying info.
            Finally it lets you verify a password against a stored password hash. 
            </summary>
        </member>
        <member name="M:PasswordUtilities.HashStorage.#ctor">
            <summary>
            Default constructor.
            </summary>
        </member>
        <member name="M:PasswordUtilities.HashStorage.HashEncode(System.String,System.String,PasswordUtilities.HashPolicy)">
            <summary>
            Encodes everything needed to store a password hash 
            so that its associated password can be verified later.
            </summary>
            <param name="passwordSalt">
            The password salt in the form of a Unicode string.
            </param>
            <param name="passwordHash">
            The password hash in the form of a Unicode string.
            </param>
            <param name="hashPolicy">
            The hash policy. This is used to extract the hash 
            algorithm, the hash work factor, and the hash 
            storage format.
            </param>
            <returns>
            ASCII string in the format ".AAAA.BBBB.NNNN.XXXX.YYYY" 
            where . = delimiter character, AAAA = hash algorithm,
            BBBB = encoding format, NNNN = work factor, 
            XXXX = encoded password salt, YYYY = encoded password hash.
            </returns>
        </member>
        <member name="M:PasswordUtilities.HashStorage.HashEncode(System.Byte[],System.Byte[],PasswordUtilities.HashPolicy)">
            <summary>
            Encodes everything needed to store a password hash 
            so that its associated password can be verified later.
            </summary>
            <param name="passwordSalt">
            The password salt in the form of a byte array.
            </param>
            <param name="passwordHash">
            The password hash in the form of a byte array.
            </param>
            <param name="hashPolicy">
            The hash policy. This is used to extract the hash 
            algorithm, the hash work factor, and the hash 
            storage format.
            </param>
            <returns>
            ASCII string in the format ".AAAA.BBBB.NNNN.XXXX.YYYY" 
            where . = delimiter character, AAAA = hash algorithm,
            BBBB = encoding format, NNNN = work factor, 
            XXXX = encoded password salt, YYYY = encoded password hash.
            </returns>
        </member>
        <member name="M:PasswordUtilities.HashStorage.HashDecode(System.String)">
            <summary>
            Decodes a stored hash into its component parts.
            </summary>
            <param name="storedHash">
            ASCII string in the format ".AAAA.BBBB.NNNN.XXXX.YYYY" 
            where . = delimiter character, AAAA = hash algorithm,
            BBBB = encoding format, NNNN = work factor, 
            XXXX = encoded password salt, YYYY = encoded password hash.
            </param>
            <returns>
            True if the stored hash is valid, or an exception. 
            explaining why the stored hash is invalid.
            </returns>
        </member>
        <member name="M:PasswordUtilities.HashStorage.ToString">
            <summary>
            Overrides the default ToString().
            </summary>
            <returns>
            The password as a Unicode (UTF-8) string. 
            </returns>
        </member>
        <member name="P:PasswordUtilities.HashStorage.HashMethod">
            <summary>
            Algorithm used to generate the hash.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashStorage.HashStorageFormat">
            <summary>
            Storage format used to encode the password 
            hash and its accompanying info.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashStorage.WorkFactor">
            <summary>
            Number of hash iterations expressed as 2^WorkFactor.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashStorage.PasswordSalt">
            <summary>
            Password salt as a byte array.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashStorage.PasswordHash">
            <summary>
            Password hash as a byte array.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashStorage.PasswordSaltEncoded">
            <summary>
            Password salt encoded using the specified storage format.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashStorage.PasswordHashEncoded">
            <summary>
            Password hash encoded using the specified storage format.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashStorage.StoredHash">
            <summary>
            ASCII string in the format ".AAAA.BBBB.NNNN.XXXX.YYYY" 
            where . = delimiter character, AAAA = hash algorithm,
            BBBB = encoding format, NNNN = work factor, 
            XXXX = encoded password salt, YYYY = encoded password hash.
            </summary>
        </member>
        <member name="T:PasswordUtilities.PasswordPolicy">
            <summary>
            Policy used to control generation and validation of passwords.
            </summary>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.#ctor">
            <summary>
            Constructor for creating the default password policy.
            </summary>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.#ctor(System.Int32,System.Int32)">
            <summary>
            Constructor for creating a specific password policy.
            </summary>
            <param name="lengthMinimum">
            Minimum length of password must be at least 0.
            </param>
            <param name="lengthMaximum">
            Maximum length of password must be no more than 200.
            </param>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.#ctor(System.Int32,System.Int32,System.Collections.Generic.IEnumerable{PasswordUtilities.CharacterSet})">
            <summary>
            Constructor for creating a specific password policy.
            </summary>
            <param name="lengthMinimum">
            Minimum length of password must be at least 4.
            </param>
            <param name="lengthMaximum">
            Maximum length of password must be no more than 200.
            </param>
            <param name="characterSets">
            Character sets that are allowed for password generation.
            </param>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.CharacterSetAdd(PasswordUtilities.CharacterSet)">
            <summary>
            Adds the specified character set to the list of allowed character sets.
            </summary>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.CharacterSetRemove(System.String)">
            <summary>
            Removes the specified character set from the list of allowed character sets.
            </summary>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.CharacterSetMinimumCharacters(System.String,System.Int32)">
            <summary>
            Reset the minimum number of characters for the specified character set.
            </summary>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.AllowedSymbolBytes">
            <summary>
            A byte array containing the symbols that can
            form a password that matches this policy.
            </summary>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.PasswordSatisfiesPolicy(System.Byte[])">
            <summary>
            Tests whether a password matches this policy.
            </summary>
            <param name="password">
            The password as a byte array.
            </param>
            <returns>
            True if the password matches this policy, otherwise false.
            </returns>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.PasswordSatisfiesPolicy(System.String)">
            <summary>
            Tests whether a password matches this policy.
            </summary>
            <param name="password">
            The password as a Unicode UTF-8 string.
            </param>
            <returns>
            True if the password matches this policy, otherwise false.
            </returns>
        </member>
        <member name="M:PasswordUtilities.PasswordPolicy.ToString">
            <summary>
            Overrides the default ToString().
            </summary>
            <returns>
            The symbols acceptable by this policy as a Unicode string.
            </returns>
        </member>
        <member name="P:PasswordUtilities.PasswordPolicy.AbsoluteLengthMinimum">
            <summary>
            The absolute minimum length of password.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordPolicy.AbsoluteLengthMaximum">
            <summary>
            The absolute maximum length of password.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordPolicy.LengthMinimum">
            <summary>
            Minimum length of current password as a Unicode string.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordPolicy.LengthMaximum">
            <summary>
            Maximum length of current password as a Unicode string.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordPolicy.MaximumPasswordRejections">
            <summary>
            Maximum number of passwords that can be rejected.
            </summary>
            <remarks>
            This prevents password generation continuing for too long.
            If this number of passwords are rejected during generation (because none of
            the passwords match the current policy), the last generated password will
            be returned.
            </remarks>
        </member>
        <member name="P:PasswordUtilities.PasswordPolicy.AllowedCharacterSets">
            <summary>
            Returns an enumeration of the allowed character sets.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordPolicy.Count">
            <summary>
            Number of allowed character sets.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordPolicy.AllowedSymbols">
            <summary>
            A Unicode string containing the symbols that can
            form a password that matches this policy.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordPolicy.MinimumNumberOfSymbols">
            <summary>
            The minimum number of mandatory symbols needed
            to form a password that matches this policy.
            </summary>
        </member>
        <member name="T:PasswordUtilities.PasswordVerifier">
            <summary>
            This class is used to check whether a specified 
            password matches a previously-stored hash.
            </summary>
        </member>
        <member name="M:PasswordUtilities.PasswordVerifier.PasswordVerify(System.String,System.String)">
            <summary>
            Verifies that the specified password matches the specified hash.
            </summary>
            <param name="password">
            The password that needs to be verified in the form of a Unicode (UTF-8) string.
            </param>
            <param name="storedHash">
            ASCII string in the format ".AAAA.BBBB.NNNN.XXXX.YYYY" 
            where . = delimiter character, AAAA = hash algorithm,
            BBBB = encoding format, NNNN = work factor, 
            XXXX = encoded password salt, YYYY = encoded password hash.
            </param>
            <returns>
            Whether the specified password matches the specified hash.
            </returns>
        </member>
        <member name="M:PasswordUtilities.PasswordVerifier.PasswordVerify(System.Byte[],System.String)">
            <summary>
            Verifies that the specified password matches the specified hash.
            </summary>
            <param name="password">
            The password that needs to be verified in the form of a Unicode (UTF-8) byte array.
            </param>
            <param name="storedHash">
            ASCII string in the format ".AAAA.BBBB.NNNN.XXXX.YYYY" 
            where . = delimiter character, AAAA = hash algorithm,
            BBBB = encoding format, NNNN = work factor, 
            XXXX = encoded password salt, YYYY = encoded password hash.
            </param>
            <returns>
            Whether the specified password matches the specified hash.
            </returns>
        </member>
        <member name="T:PasswordUtilities.StorageFormat">
            <summary>
            List of password storage formats.
            </summary>
            <remarks>
            Currently only handles base64 and hexadecimal.
            </remarks>
        </member>
        <member name="F:PasswordUtilities.StorageFormat.Hexadecimal">
            <summary>
            Store password salt and password hash as a hexadecimal string.
            Hex takes 2 characters to represent 1 byte, so is less space-efficient than Base64.
            </summary>
        </member>
        <member name="F:PasswordUtilities.StorageFormat.Base64">
            <summary>
            Store password salt and password hash as a base64 string.
            Base64 takes 4 characters to represent 3 bytes, so is more space-efficient than hex.
            </summary>
        </member>
        <member name="T:PasswordUtilities.PasswordGenerator">
            <summary>
            This class uses a password policy to generate random Unicode passwords 
            which do not include ambiguous characters such as I, l, O, 0, and 1. 
            </summary>
            <remarks>
            Each generated password is a Unicode string composed of 
            symbols taken from the symbol types specified in the policy.
            A cryptographically-secure PNRG does the password generation. 
            You can provide a password policy (or use the default policy) 
            to dictate the password length and the permitted symbol types.
            </remarks>
        </member>
        <member name="M:PasswordUtilities.PasswordGenerator.#ctor">
            <summary>
            Use the default password policy.
            </summary>
            <remarks>
            If you use the default password policy with the default hash policy,
            you will have a combined entropy of around 83 bits - greater than 
            NIST's recommendation of 80 bits for the most secure passwords.
            </remarks>
        </member>
        <member name="M:PasswordUtilities.PasswordGenerator.#ctor(PasswordUtilities.PasswordPolicy)">
            <summary>
            Use the specified password policy.
            </summary>
        </member>
        <member name="M:PasswordUtilities.PasswordGenerator.GeneratePassword">
            <summary>
            Generates password using the current password policy.
            </summary>
            <returns>
            Password as a Unicode (UTF-8) string.
            </returns>
        </member>
        <member name="M:PasswordUtilities.PasswordGenerator.ToString">
            <summary>
            Overrides the default ToString().
            </summary>
            <returns>
            The password as a Unicode (UTF-8) string. 
            </returns>
        </member>
        <member name="P:PasswordUtilities.PasswordGenerator.Password">
            <summary>
            Generated password as a Unicode string.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordGenerator.PasswordBytes">
            <summary>
            Generated password as a byte array.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordGenerator.Policy">
            <summary>
            Current password policy.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordGenerator.GenerationTime">
            <summary>
            Time taken to generate the password.
            </summary>
        </member>
        <member name="P:PasswordUtilities.PasswordGenerator.PasswordEntropy">
            <summary>
            Generated password entropy in bits. 
            </summary>
            <remarks>
            For a machine-generated random password, this is equivalent to the password 
            strength. For more details, see http://en.wikipedia.org/wiki/Password_strength
            In 1998, the EFF cracked a 56-bit key in 56 hours using specialised FPGA hardware.
            In 2002, distributed.net cracked a 64-bit key in 4 years, 9 months, and 23 days.
            In August 2010, distributed.net estimated that cracking a 72-bit key using 
            current hardware would take about 48,712 days or 133.5 years.
            NIST recommends 80 bits for the most secure passwords up until 2014.
            </remarks>
        </member>
        <member name="P:PasswordUtilities.PasswordGenerator.PasswordRejectedCount">
            <summary>
            Number of random passwords generated before 
            password matching specified policy is found. 
            </summary>
        </member>
        <member name="T:PasswordUtilities.HashGenerator">
            <summary>
            This class generates a randomly-salted hash for a specified password.
            This means you can store the salt and hash and never need to store the password.
            This class can also verify that a specified password and stored salt matches a stored hash. 
            </summary>
            <remarks>
            A random salt makes the use of a rainbow table cracker (such as Ophcrack) much harder. 
            A large number of hash iterations makes the use of an incremental cracker (such as LC5) much harder.
            But nothing will save you if the password is very weak, e.g. something like "passw0rd".
            http://chargen.matasano.com/chargen/2007/9/7/enough-with-the-rainbow-tables-what-you-need-to-know-about-s.html
            </remarks>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.#ctor">
            <summary>
            Use the default hash policy.
            </summary>
            <remarks>
            If you use the default password policy with the default hash policy,
            you will have a combined entropy of around 83 bits - greater than 
            NIST's recommendation of 80 bits for the most secure passwords.
            </remarks>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.#ctor(PasswordUtilities.HashPolicy)">
            <summary>
            Use the specified hash policy.
            </summary>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.CreatePasswordSalt">
            <summary>
            Creates a random password salt using the specified hash policy.
            </summary>
            <returns>
            The password salt as a Unicode (UTF-8) byte array.
            </returns>
            <remarks>
            As a side-effect this method 
            populates the password salt property. 
            </remarks>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.CreatePasswordHash(System.String)">
            <summary>
            Hashes the specified password and a random salt using a specified hash policy.
            </summary>
            <param name="password">
            The password that needs to be hashed in the form of a Unicode (UTF-8) string.
            </param>
            <returns>
            The password hash as a Unicode (UTF-8) byte array.
            </returns>
            <remarks>
            The password salt must already be available 
            via a previous call to CreatePasswordSalt().
            As a side-effect this method populates 
            the password and password hash properties. 
            </remarks>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.CreatePasswordHash(System.String,System.String)">
            <summary>
            Hashes the specified password and a random salt using a specified hash policy.
            </summary>
            <param name="password">
            The password that needs to be hashed in the form of a Unicode (UTF-8) string.
            </param>
            <param name="salt">
            The password salt in the form of a Unicode (UTF-8) string.
            </param>
            <returns>
            The password hash as a Unicode (UTF-8) byte array.
            </returns>
            <remarks>
            As a side-effect this method populates the
            password, password salt, and password hash properties. 
            </remarks>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.CreatePasswordHash(System.Byte[])">
            <summary>
            Hashes the specified password and a random salt using a specified hash policy.
            </summary>
            <param name="password">
            The password that needs to be hashed as a Unicode (UTF-8) byte array.
            </param>
            <returns>
            The password hash as a Unicode (UTF-8) byte array.
            </returns>
            <remarks>
            As a side-effect this method populates 
            the password and password hash properties. 
            </remarks>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.CreatePasswordHash(System.Byte[],System.Byte[])">
            <summary>
            Hashes the specified password and a random salt using a specified hash policy.
            </summary>
            <param name="password">
            The password that needs to be hashed as a Unicode (UTF-8) byte array.
            </param>
            <returns>
            The password hash as a Unicode (UTF-8) byte array.
            </returns>
            <param name="salt">
            The password salt as a Unicode (UTF-8) byte array.
            </param>
            <remarks>
            The password salt must already be available 
            via a previous call to CreatePasswordSalt().
            As a side-effect this method populates the
            password, password salt, and password hash properties. 
            </remarks>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.CreatePasswordSaltAndHash(System.String)">
            <summary>
            Hashes the specified password and a random salt using a specified hash policy.
            </summary>
            <param name="password">
            The password that needs to be hashed as a Unicode (UTF-8) string.
            </param>
            <returns>
            The password hash as a Unicode (UTF-8) byte array.
            </returns>
            <remarks>
            As a side-effect this method populates the 
            password, password salt, and password hash properties. 
            </remarks>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.CreatePasswordSaltAndHash(System.Byte[])">
            <summary>
            Hashes the specified password and a random salt using a specified hash policy.
            </summary>
            <param name="password">
            The password that needs to be hashed as a Unicode (UTF-8) byte array.
            </param>
            <returns>
            The password hash as a Unicode (UTF-8) byte array.
            </returns>
            <remarks>
            As a side-effect this method populates the 
            password, password salt, and password hash properties. 
            </remarks>
        </member>
        <member name="M:PasswordUtilities.HashGenerator.ToString">
            <summary>
            Overrides the default ToString().
            </summary>
            <returns>
            The password hash. 
            </returns>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.Password">
            <summary>
            Supplied password converted to a UTF-8 string.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.PasswordBytes">
            <summary>
            Supplied password is always stored as a UTF-8 byte array.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.Salt">
            <summary>
            Generated salt bytes converted to a UTF-8 Unicode string.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.SaltBytes">
            <summary>
            Generated salt is always stored as a byte array.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.HashBytes">
            <summary>
            Generated hash is always stored as a byte array.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.GenerationTime">
            <summary>
            Time taken to perform the iterated hash calculation.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.Policy">
            <summary>
            The policy used to control hash generation.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.HashEncoded">
            <summary>
            Password hash encoded using the specified storage format.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.SaltEncoded">
            <summary>
            Password salt encoded using the specified storage format.
            </summary>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.HashEntropy">
            <summary>
            Estimates the added entropy added to the password by this hash.
            </summary>
            <returns>
            The hash entropy in bits. 
            </returns>
        </member>
        <member name="P:PasswordUtilities.HashGenerator.StoredHash">
            <summary>
            Returns all the hash details in a format suitable 
            for storage and for password verification.
            </summary>
            <returns>
            ASCII string in the format ".AAAA.BBBB.NNNN.XXXX.YYYY" 
            where . = delimiter character, AAAA = hash algorithm,
            BBBB = encoding format, NNNN = work factor, 
            XXXX = encoded password salt, YYYY = encoded password hash.
            </returns>
        </member>
        <member name="T:PasswordUtilities.PasswordStrength">
            <summary>
            List of password strength ranges based on the password policy,
            estimated symbol set, password source, and password  entropy.
            </summary>
            <remarks>
            This is a bit of a guesstimate, and will be increasingly inaccurate
            as hardware scales up (CPU speed, memory speed/size) and out (grids, 
            GPUs, FPGAs, etc).
            For more details, see http://en.wikipedia.org/wiki/Password_strength
            </remarks>
        </member>
        <member name="F:PasswordUtilities.PasswordStrength.Weak">
            <summary>
            Password is probably weak in today's terms (2011).
            </summary>
        </member>
        <member name="F:PasswordUtilities.PasswordStrength.Adequate">
            <summary>
            Password is probably adequate in today's terms (2011).
            </summary>
        </member>
        <member name="F:PasswordUtilities.PasswordStrength.Strong">
            <summary>
            Password is probably strong in today's terms (2011).
            </summary>
        </member>
        <member name="F:PasswordUtilities.PasswordStrength.VeryStrong">
            <summary>
            Password is probably very strong in today's terms (2011).
            </summary>
        </member>
    </members>
</doc>
